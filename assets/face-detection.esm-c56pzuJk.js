import{a as nt}from"./face_detection-DlDqH99F.js";import{e as pe,t as it,c as Xe,O as ut,a as ot,b as pt,d as mt,f as U,g as lt,h as ct,i as dt,j as ht,k as yt,l as ft,m as gt,n as Nt,o as bt,p as Tt,q as St,r as wt,s as _t,u as Ot,v as vt,w as It,x as Et,y as At,z as kt,A as zt,B as Lt,C as Dt,D as Ct,E as Vt,F as De,G as xt,H as Ye,I as Ft,J as ee,K as Rt,L as Pt,M as $t,N as jt,P as Bt,Q as Ht,R as Ut,S as qt,T as Wt,U as Gt,V as Kt,W as Qt,X as Xt,Y as Yt,Z as Zt,_ as Jt,$ as Mt,a0 as ea,a1 as ta,a2 as C,a3 as aa,a4 as sa,a5 as ra,a6 as na,a7 as ia,a8 as ua,a9 as oa,aa as pa,ab as ma,ac as la,ad as Ne,ae as Ce,af as ca,ag as da,ah as ha,ai as ya,aj as fa,ak as ga,al as Na,am as ba,an as Ta,ao as Sa,ap as wa,aq as _a,ar as Oa,as as de,at as va,au as Ia,av as Ea,aw as Aa,ax as ka,ay as za,az as La,aA as Da,aB as Ca,aC as Va,aD as xa,aE as Fa,aF as Ra,aG as Pa,aH as $a,aI as ja,aJ as Ba,aK as Ha,aL as Ua,aM as qa,aN as Wa,aO as Ga,aP as Ka,aQ as Qa,aR as Xa,aS as Ya,aT as Za,aU as Ja,aV as Ma,aW as es,aX as ts,aY as as,aZ as ss,a_ as rs,a$ as ns,b0 as is,b1 as x,b2 as us,b3 as os,b4 as ps,b5 as ms,b6 as ls,b7 as cs,b8 as ds,b9 as hs,ba as ys,bb as fs,bc as gs,bd as Ns,be as bs,bf as Ts,bg as Ss,bh as ws,bi as _s,bj as Os,bk as vs,bl as Is,bm as Es,bn as As,bo as ks,bp as zs,bq as Ls,br as Ds,bs as Cs,bt as Vs,bu as xs,bv as Fs,bw as Rs,bx as Ps,by as $s,bz as js,bA as k,bB as Bs,bC as Hs,bD as Us,bE as qs,bF as Ws,bG as Gs,bH as Ks,bI as Qs,bJ as q,bK as Xs,bL as Ys,bM as Zs,bN as Js,bO as Ms,bP as Ze,bQ as er,bR as tr,bS as ar,bT as sr,bU as I,bV as rr,bW as nr,bX as ir,bY as ur,bZ as or,b_ as pr,b$ as mr,c0 as lr,c1 as cr,c2 as dr,c3 as hr,c4 as yr,c5 as fr,c6 as gr,c7 as A,c8 as te,c9 as Nr,ca as br,cb as Tr,cc as be,cd as Sr,ce as wr,cf as _r,cg as ae,ch as Y,ci as Ve,cj as Or,ck as vr,cl as Ir,cm as Er,cn as Ar,co as kr,cp as zr,cq as Lr,cr as Dr,cs as Cr,ct as Vr,cu as re,cv as xr,cw as Fr,cx as Rr,cy as Pr,cz as $r,cA as jr,cB as K,cC as P,cD as E,cE as Fe,cF as me,cG as Je,cH as Br,cI as se,cJ as Z,cK as Hr,cL as Ur}from"./index-DToXWtim.js";/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qr=pe();qr.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,a=>{a&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var z;(function(a){a[a.DT_INVALID=0]="DT_INVALID",a[a.DT_FLOAT=1]="DT_FLOAT",a[a.DT_DOUBLE=2]="DT_DOUBLE",a[a.DT_INT32=3]="DT_INT32",a[a.DT_UINT8=4]="DT_UINT8",a[a.DT_INT16=5]="DT_INT16",a[a.DT_INT8=6]="DT_INT8",a[a.DT_STRING=7]="DT_STRING",a[a.DT_COMPLEX64=8]="DT_COMPLEX64",a[a.DT_INT64=9]="DT_INT64",a[a.DT_BOOL=10]="DT_BOOL",a[a.DT_QINT8=11]="DT_QINT8",a[a.DT_QUINT8=12]="DT_QUINT8",a[a.DT_QINT32=13]="DT_QINT32",a[a.DT_BFLOAT16=14]="DT_BFLOAT16",a[a.DT_QINT16=15]="DT_QINT16",a[a.DT_QUINT16=16]="DT_QUINT16",a[a.DT_UINT16=17]="DT_UINT16",a[a.DT_COMPLEX128=18]="DT_COMPLEX128",a[a.DT_HALF=19]="DT_HALF",a[a.DT_RESOURCE=20]="DT_RESOURCE",a[a.DT_VARIANT=21]="DT_VARIANT",a[a.DT_UINT32=22]="DT_UINT32",a[a.DT_UINT64=23]="DT_UINT64",a[a.DT_FLOAT_REF=101]="DT_FLOAT_REF",a[a.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",a[a.DT_INT32_REF=103]="DT_INT32_REF",a[a.DT_UINT8_REF=104]="DT_UINT8_REF",a[a.DT_INT16_REF=105]="DT_INT16_REF",a[a.DT_INT8_REF=106]="DT_INT8_REF",a[a.DT_STRING_REF=107]="DT_STRING_REF",a[a.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",a[a.DT_INT64_REF=109]="DT_INT64_REF",a[a.DT_BOOL_REF=110]="DT_BOOL_REF",a[a.DT_QINT8_REF=111]="DT_QINT8_REF",a[a.DT_QUINT8_REF=112]="DT_QUINT8_REF",a[a.DT_QINT32_REF=113]="DT_QINT32_REF",a[a.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",a[a.DT_QINT16_REF=115]="DT_QINT16_REF",a[a.DT_QUINT16_REF=116]="DT_QUINT16_REF",a[a.DT_UINT16_REF=117]="DT_UINT16_REF",a[a.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",a[a.DT_HALF_REF=119]="DT_HALF_REF",a[a.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",a[a.DT_VARIANT_REF=121]="DT_VARIANT_REF",a[a.DT_UINT32_REF=122]="DT_UINT32_REF",a[a.DT_UINT64_REF=123]="DT_UINT64_REF"})(z||(z={}));var Re;(function(a){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(a.CheckpointFormatVersion||(a.CheckpointFormatVersion={}))})(Re||(Re={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wr={};function Me(a){return Wr[a]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r(a,e,t,s,n){const i=e.inputParams[a];if(i&&i.inputIndexStart!==void 0){const u=i.inputIndexStart,p=i.inputIndexEnd===0?void 0:i.inputIndexEnd===void 0?u+1:i.inputIndexEnd,l=u<0?e.inputNames.length+u:u;if(i.type==="tensor")return O(e.inputNames[l],t,s,n);if(i.type==="tensors"){const d=e.inputs.slice(u,p);return e.inputNames.slice(u,p).filter((f,g)=>{var y;return((y=d[g])===null||y===void 0?void 0:y.op)!=="NoOp"}).map(f=>O(f,t,s,n))}const m=O(e.inputNames[l],t,s,n),c=m.dataSync();return i.type==="number"?c[0]:it(m.shape,c)}const o=e.attrParams[a];return o&&o.value}function O(a,e,t,s){const[n,i]=L(a,t);if(s!=null){const u=s.getHashTableHandleByName(n);if(u!=null)return u}const o=t.currentContextIds.find(u=>!!e[le(n,u)]);return o!==void 0?e[le(n,o)][i]:void 0}function Pe(a,e,t){return e[le(a,t.currentContextId)]}function F(a,e){const[t,s,n]=L(a,e);return[le(t,e&&e.currentContextId),s,n]}function le(a,e){return e?`${a}-${e}`:a}function L(a,e){if(a==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const i=e.parseNodeNameCache.get(a);if(i!=null)return i}const s=a.split(":");let n;if(s.length===1)n=[a,0,void 0];else{const i=s[0],o=s.length===3?s[1]:void 0,u=Number(s[s.length-1]);n=[i,u,o]}return t&&e.parseNodeNameCache.set(a,n),n}function oe(a,e,t){let s=r("pad",a,e,t);if(s==="explicit"){s=r("explicitPaddings",a,e,t);const n=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)n[i][0]=s[i*2],n[i][1]=s[i*2+1];return n}return s}function R(a){return a.kept?a:Xe(a)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gr=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Kr=Object.freeze(Object.defineProperty({__proto__:null,json:Gr},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qr=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Xr=Object.freeze(Object.defineProperty({__proto__:null,json:Qr},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yr=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],Zr=Object.freeze(Object.defineProperty({__proto__:null,json:Yr},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jr=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Mr=Object.freeze(Object.defineProperty({__proto__:null,json:Jr},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const en=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],tn=Object.freeze(Object.defineProperty({__proto__:null,json:en},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const an=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],sn=Object.freeze(Object.defineProperty({__proto__:null,json:an},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rn=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],nn=Object.freeze(Object.defineProperty({__proto__:null,json:rn},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const un=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],on=Object.freeze(Object.defineProperty({__proto__:null,json:un},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pn=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],mn=Object.freeze(Object.defineProperty({__proto__:null,json:pn},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ln=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],cn=Object.freeze(Object.defineProperty({__proto__:null,json:ln},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dn=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],hn=Object.freeze(Object.defineProperty({__proto__:null,json:dn},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yn=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],fn=Object.freeze(Object.defineProperty({__proto__:null,json:yn},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gn=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Nn=Object.freeze(Object.defineProperty({__proto__:null,json:gn},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bn=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Tn=Object.freeze(Object.defineProperty({__proto__:null,json:bn},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sn=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],wn=Object.freeze(Object.defineProperty({__proto__:null,json:Sn},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _n=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],On=Object.freeze(Object.defineProperty({__proto__:null,json:_n},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vn=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],In=Object.freeze(Object.defineProperty({__proto__:null,json:vn},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const En=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],An=Object.freeze(Object.defineProperty({__proto__:null,json:En},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kn=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],zn=Object.freeze(Object.defineProperty({__proto__:null,json:kn},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $e{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[Kr,Xr,Zr,Mr,tn,sn,nn,on,mn,cn,hn,fn,Nn,Tn,wn,On,In,An,zn],t=[].concat(...e.map(s=>s.json));this.opMappers=t.reduce((s,n)=>(s[n.tfOpName]=n,s),{})}transformGraph(e,t={}){const s=e.node,n=[],i=[],o=[],u=s.reduce((g,y)=>(g[y.name]=this.mapNode(y),y.op.startsWith("Placeholder")?n.push(g[y.name]):y.op==="Const"?i.push(g[y.name]):(y.input==null||y.input.length===0)&&o.push(g[y.name]),g),{});let p=[];const l=[];let m={},c={};t!=null&&(m=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));const d=Object.keys(u);d.forEach(g=>{const y=u[g];y.inputNames.forEach((N,T)=>{const[w,,b]=F(N),S=u[w];if(S.outputs!=null){const _=S.outputs.indexOf(b);if(_!==-1){const D=`${w}:${_}`;y.inputNames[T]=D}}y.inputs.push(S),S.children.push(y)})}),Object.keys(c).length===0?d.forEach(g=>{const y=u[g];y.children.length===0&&l.push(y)}):Object.keys(c).forEach(g=>{const[y]=F(g),N=u[y];N!=null&&(N.signatureKey=c[g],l.push(N))}),Object.keys(m).length>0?Object.keys(m).forEach(g=>{const[y]=F(g),N=u[y];N&&(N.signatureKey=m[g],p.push(N))}):p=n;let h={};e.library!=null&&e.library.function!=null&&(h=e.library.function.reduce((g,y)=>(g[y.signature.name]=this.mapFunction(y),g),{}));const f={nodes:u,inputs:p,outputs:l,weights:i,placeholders:n,signature:t,functions:h};return o.length>0&&(f.initNodes=o),f}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,s)=>(t[e[s].name]=s,t),{})}mapNode(e){const t=Me(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(n=>n.startsWith("^")?n.slice(1):n),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(s.inputParams=t.inputs.reduce((n,i)=>(n[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},n),{})),t.attrs!=null&&(s.attrParams=t.attrs.reduce((n,i)=>{const o=i.type;let u;switch(i.type){case"string":u=Te(e.attr,i.tfName,i.defaultValue),u===void 0&&i.tfDeprecatedName&&(u=Te(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":u=Ee(e.attr,i.tfName,i.defaultValue),u===void 0&&i.tfDeprecatedName&&(u=Ee(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":u=we(e.attr,i.tfName,i.defaultValue||0),u===void 0&&i.tfDeprecatedName&&(u=we(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":u=Ie(e.attr,i.tfName,i.defaultValue),u===void 0&&i.tfDeprecatedName&&(u=Ie(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":u=Se(e.attr,i.tfName,i.defaultValue),u===void 0&&i.tfDeprecatedName&&(u=Se(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":u=ke(e.attr,i.tfName,i.defaultValue),u===void 0&&i.tfDeprecatedName&&(u=ke(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":u=ve(e.attr,i.tfName,i.defaultValue),u===void 0&&i.tfDeprecatedName&&(u=ve(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":u=Ae(e.attr,i.tfName,i.defaultValue),u===void 0&&i.tfDeprecatedName&&(u=Ae(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":u=_e(e.attr,i.tfName,i.defaultValue),u===void 0&&i.tfDeprecatedName&&(u=_e(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":u=Oe(e.attr,i.tfName,i.defaultValue),u===void 0&&i.tfDeprecatedName&&(u=Oe(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":u=je(e.attr,i.tfName,i.defaultValue),u===void 0&&i.tfDeprecatedName&&(u=je(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${i.type} for op: ${e.op}`)}return n[i.name]={value:u,type:o},n},{})),s}mapFunction(e){const t=e.nodeDef,s=[],n=[];let i={};t!=null&&(i=t.reduce((c,d)=>(c[d.name]=this.mapNode(d),d.op==="Const"&&n.push(c[d.name]),c),{}));const o=[],u=[];e.signature.inputArg.forEach(c=>{const[d]=F(c.name),h={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:xe(c.type),type:"dtype"}},children:[]};h.signatureKey=c.name,o.push(h),i[d]=h}),Object.keys(i).forEach(c=>{const d=i[c];d.inputNames.forEach((h,f)=>{const[g,,y]=F(h),N=i[g];if(N.outputs!=null){const T=N.outputs.indexOf(y);if(T!==-1){const w=`${g}:${T}`;d.inputNames[f]=w}}d.inputs.push(N),N.children.push(d)})});const l=e.ret;e.signature.outputArg.forEach(c=>{const[d,h]=F(l[c.name]),f=i[d];f!=null&&(f.defaultOutput=h,u.push(f))});const m=this.mapArgsToSignature(e);return{nodes:i,inputs:o,outputs:u,weights:n,placeholders:s,signature:m}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s),t),{}),outputs:e.signature.outputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s,e.ret),t),{})}}mapArgToTensorInfo(e,t){let s=e.name;return t!=null&&(s=t[s]),{name:s,dtype:e.type}}}function Ln(a){const e=pe().global;if(typeof e.atob<"u")return e.atob(a);if(typeof Buffer<"u")return new Buffer(a,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function et(a,e){const t=Array.isArray(a)?String.fromCharCode.apply(null,a):Ln(a);return e?t:t.toLowerCase()}function Te(a,e,t,s=!1){const n=a[e];return n!=null?et(n.s,s):t}function Se(a,e,t){const s=a[e];return s?s.b:t}function we(a,e,t){const s=a[e]||{},n=s.i!=null?s.i:s.f!=null?s.f:t;return typeof n=="number"?n:parseInt(n,10)}function xe(a){switch(typeof a=="string"&&(a=z[a]),a){case z.DT_FLOAT:case z.DT_HALF:return"float32";case z.DT_INT32:case z.DT_INT64:case z.DT_INT8:case z.DT_UINT8:return"int32";case z.DT_BOOL:return"bool";case z.DT_DOUBLE:return"float32";case z.DT_STRING:return"string";case z.DT_COMPLEX64:case z.DT_COMPLEX128:return"complex64";default:return null}}function je(a,e,t){const s=a[e];return s&&s.func?s.func.name:t}function _e(a,e,t){const s=a[e];return s&&s.type?xe(s.type):t}function Oe(a,e,t){const s=a[e];return s&&s.list&&s.list.type?s.list.type.map(n=>xe(n)):t}function tt(a){if(!a.unknownRank)return a.dim!=null?a.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function ve(a,e,t){const s=a[e];return s&&s.shape?tt(s.shape):t}function Ie(a,e,t){const s=a[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(n=>typeof n=="number"?n:parseInt(n,10)):t}function Ee(a,e,t,s=!1){const n=a[e];return n&&n.list&&n.list.s?n.list.s.map(i=>et(i,s)):t}function Ae(a,e,t){const s=a[e];return s&&s.list&&s.list.shape?s.list.shape.map(n=>tt(n)):t}function ke(a,e,t){const s=a[e];return s&&s.list&&s.list.b?s.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dn{constructor(e,t,s){this.node=e,this.tensorMap=t,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(n=>this.getInput(n)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((n,i)=>(n[i]=this.getAttr(i),n),{}))}getInput(e){return O(e,this.tensorMap,this.context)}getAttr(e,t){const s=this.node.rawAttrs[e];if(s.tensor!=null)return O(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return we(this.node.rawAttrs,e,t);if(s.s!=null)return Te(this.node.rawAttrs,e,t);if(s.b!=null)return Se(this.node.rawAttrs,e,t);if(s.shape!=null)return ve(this.node.rawAttrs,e,t);if(s.type!=null)return _e(this.node.rawAttrs,e,t);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return Ie(this.node.rawAttrs,e,t);if(s.list.s!=null)return Ee(this.node.rawAttrs,e,t);if(s.list.shape!=null)return Ae(this.node.rawAttrs,e,t);if(s.list.b!=null)return ke(this.node.rawAttrs,e,t);if(s.list.type!=null)return Oe(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:ut,abs:ot,acos:pt,acosh:mt,add:U,addN:lt,all:ct,any:dt,argMax:ht,argMin:yt,asin:ft,asinh:gt,atan:Nt,atan2:bt,atanh:Tt,avgPool:St,avgPool3d:wt,basicLSTMCell:_t,batchNorm:Ot,batchNorm2d:vt,batchNorm3d:It,batchNorm4d:Et,batchToSpaceND:At,bincount:kt,bitwiseAnd:zt,booleanMaskAsync:Lt,broadcastArgs:Dt,broadcastTo:Ct,buffer:Vt,cast:De,ceil:xt,clipByValue:Ye,clone:Xe,complex:Ft,concat:ee,concat1d:Rt,concat2d:Pt,concat3d:$t,concat4d:jt,conv1d:Bt,conv2d:Ht,conv2dTranspose:Ut,conv3d:qt,conv3dTranspose:Wt,cos:Gt,cosh:Kt,cosineWindow:Qt,cumprod:Xt,cumsum:Yt,denseBincount:Zt,depthToSpace:Jt,depthwiseConv2d:Mt,diag:ea,dilation2d:ta,div:C,divNoNan:aa,dot:sa,dropout:ra,einsum:na,elu:ia,enclosingPowerOfTwo:ua,ensureShape:oa,equal:pa,erf:ma,euclideanNorm:la,exp:Ne,expandDims:Ce,expm1:ca,eye:da,fft:ha,fill:ya,floor:fa,floorDiv:ga,fused:Na,gather:ba,gatherND:Ta,greater:Sa,greaterEqual:wa,ifft:_a,imag:Oa,image:de,inTopKAsync:va,irfft:Ia,isFinite:Ea,isInf:Aa,isNaN:ka,leakyRelu:za,less:La,lessEqual:Da,linalg:Ca,linspace:Va,localResponseNormalization:xa,log:Fa,log1p:Ra,logSigmoid:Pa,logSoftmax:$a,logSumExp:ja,logicalAnd:Ba,logicalNot:Ha,logicalOr:Ua,logicalXor:qa,losses:Wa,lowerBound:Ga,matMul:Ka,max:Qa,maxPool:Xa,maxPool3d:Ya,maxPoolWithArgmax:Za,maximum:Ja,mean:Ma,meshgrid:es,min:ts,minimum:as,mirrorPad:ss,mod:rs,moments:ns,movingAverage:is,mul:x,multiRNNCell:us,multinomial:os,neg:ps,norm:ms,notEqual:ls,oneHot:cs,ones:ds,onesLike:hs,op:ys,outerProduct:fs,pad:gs,pad1d:Ns,pad2d:bs,pad3d:Ts,pad4d:Ss,pool:ws,pow:_s,prelu:Os,print:vs,prod:Is,raggedGather:Es,raggedRange:As,raggedTensorToTensor:ks,rand:zs,randomGamma:Ls,randomNormal:Ds,randomStandardNormal:Cs,randomUniform:Vs,randomUniformInt:xs,range:Fs,real:Rs,reciprocal:Ps,relu:$s,relu6:js,reshape:k,reverse:Bs,reverse1d:Hs,reverse2d:Us,reverse3d:qs,reverse4d:Ws,rfft:Gs,round:Ks,rsqrt:Qs,scalar:q,scatterND:Xs,searchSorted:Ys,selu:Zs,separableConv2d:Js,setdiff1dAsync:Ms,sigmoid:Ze,sign:er,signal:tr,sin:ar,sinh:sr,slice:I,slice1d:rr,slice2d:nr,slice3d:ir,slice4d:ur,softmax:or,softplus:pr,spaceToBatchND:mr,sparse:lr,sparseToDense:cr,spectral:dr,split:hr,sqrt:yr,square:fr,squaredDifference:gr,squeeze:A,stack:te,step:Nr,stridedSlice:br,string:Tr,sub:be,sum:Sr,tan:wr,tanh:_r,tensor:ae,tensor1d:Y,tensor2d:Ve,tensor3d:Or,tensor4d:vr,tensor5d:Ir,tensor6d:Er,tensorScatterUpdate:Ar,tile:kr,topk:zr,transpose:Lr,truncatedNormal:Dr,unique:Cr,unsortedSegmentSum:Vr,unstack:re,upperBound:xr,variable:Fr,where:Rr,whereAsync:Pr,zeros:$r,zerosLike:jr},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cn=(a,e,t,s=v)=>{switch(a.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(r("a",a,e,t),r("b",a,e,t))];case"AddN":return[s.addN(r("tensors",a,e,t))];case"FloorMod":case"Mod":return[s.mod(r("a",a,e,t),r("b",a,e,t))];case"Mul":return[s.mul(r("a",a,e,t),r("b",a,e,t))];case"RealDiv":case"Div":return[s.div(r("a",a,e,t),r("b",a,e,t))];case"DivNoNan":return[s.divNoNan(r("a",a,e,t),r("b",a,e,t))];case"FloorDiv":return[s.floorDiv(r("a",a,e,t),r("b",a,e,t))];case"Sub":return[s.sub(r("a",a,e,t),r("b",a,e,t))];case"Minimum":return[s.minimum(r("a",a,e,t),r("b",a,e,t))];case"Maximum":return[s.maximum(r("a",a,e,t),r("b",a,e,t))];case"Pow":return[s.pow(r("a",a,e,t),r("b",a,e,t))];case"SquaredDifference":return[s.squaredDifference(r("a",a,e,t),r("b",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vn=(a,e,t,s=v)=>{switch(a.op){case"Abs":case"ComplexAbs":return[s.abs(r("x",a,e,t))];case"Acos":return[s.acos(r("x",a,e,t))];case"Acosh":return[s.acosh(r("x",a,e,t))];case"Asin":return[s.asin(r("x",a,e,t))];case"Asinh":return[s.asinh(r("x",a,e,t))];case"Atan":return[s.atan(r("x",a,e,t))];case"Atan2":return[s.atan2(r("x",a,e,t),r("y",a,e,t))];case"Atanh":return[s.atanh(r("x",a,e,t))];case"Ceil":return[s.ceil(r("x",a,e,t))];case"Complex":return[s.complex(r("real",a,e,t),r("imag",a,e,t))];case"Cos":return[s.cos(r("x",a,e,t))];case"Cosh":return[s.cosh(r("x",a,e,t))];case"Elu":return[s.elu(r("x",a,e,t))];case"Erf":return[s.erf(r("x",a,e,t))];case"Exp":return[s.exp(r("x",a,e,t))];case"Expm1":return[s.expm1(r("x",a,e,t))];case"Floor":return[s.floor(r("x",a,e,t))];case"Log":return[s.log(r("x",a,e,t))];case"Log1p":return[s.log1p(r("x",a,e,t))];case"Imag":return[s.imag(r("x",a,e,t))];case"Neg":return[s.neg(r("x",a,e,t))];case"Reciprocal":return[s.reciprocal(r("x",a,e,t))];case"Real":return[s.real(r("x",a,e,t))];case"Relu":return[s.relu(r("x",a,e,t))];case"Round":return[s.round(r("x",a,e,t))];case"Selu":return[s.selu(r("x",a,e,t))];case"Sigmoid":return[s.sigmoid(r("x",a,e,t))];case"Sin":return[s.sin(r("x",a,e,t))];case"Sign":return[s.sign(r("x",a,e,t))];case"Sinh":return[s.sinh(r("x",a,e,t))];case"Softplus":return[s.softplus(r("x",a,e,t))];case"Sqrt":return[s.sqrt(r("x",a,e,t))];case"Square":return[s.square(r("x",a,e,t))];case"Tanh":return[s.tanh(r("x",a,e,t))];case"Tan":return[s.tan(r("x",a,e,t))];case"ClipByValue":return[s.clipByValue(r("x",a,e,t),r("clipValueMin",a,e,t),r("clipValueMax",a,e,t))];case"Relu6":return[s.relu6(r("x",a,e,t))];case"Rsqrt":return[s.rsqrt(O(a.inputNames[0],e,t))];case"LeakyRelu":return[s.leakyRelu(r("x",a,e,t),r("alpha",a,e,t))];case"Prelu":return[s.prelu(r("x",a,e,t),r("alpha",a,e,t))];case"IsNan":return[s.isNaN(O(a.inputNames[0],e,t))];case"IsInf":return[s.isInf(O(a.inputNames[0],e,t))];case"IsFinite":return[s.isFinite(O(a.inputNames[0],e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V(a,e,t=""){if(!(typeof a=="number"||typeof e=="number")){K(a.length===e.length,()=>t+` Shapes ${a} and ${e} must match`);for(let s=0;s<a.length;s++){const n=a[s],i=e[s];K(n<0||i<0||n===i,()=>t+` Shapes ${a} and ${e} must match`)}}}function Be(a){return!(typeof a=="number"||a.some(e=>e<0))}function M(a,e,t){let s=ze(a,t);const n=!Be(s);if(n&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(n&&e.forEach(i=>{s=ze(i.shape,s)}),!Be(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function ze(a,e){if(typeof a=="number")return e;if(typeof e=="number")return a;if(a.length!==e.length)throw new Error(`Incompatible ranks during merge: ${a} vs. ${e}`);const t=[];for(let s=0;s<a.length;++s){const n=a[s],i=e[s];if(n>=0&&i>=0&&n!==i)throw new Error(`Incompatible shape during merge: ${a} vs. ${e}`);t[s]=n>=0?n:i}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xn{constructor(e,t,s,n,i,o,u){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=n,this.identicalElementShapes=i,this.dynamicSize=o,this.clearAfterRead=u,this.tensors=[],this.closed_=!1,this.idTensor=q(0),P(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),V(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,P(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((s,n)=>this.write(s,t[n]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let n=0;n<this.size();n++)e.push(n)}if(e.length===0)return ae([],[0].concat(this.elementShape));const s=this.readMany(e);return V(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),te(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return ae([],[0].concat(this.elementShape));const t=[];for(let n=0;n<this.size();n++)t.push(n);const s=this.readMany(t);return V(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),ee(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,re(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const n=e.map(p=>(s+=p,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const i=s===0?0:t.size/s,o=[];E(()=>{t=k(t,[1,s,i]);for(let p=0;p<e.length;++p){const m=[0,p===0?0:n[p-1],0],c=[1,e[p],i];o[p]=k(I(t,m,c),this.elementShape)}return o});const u=[];for(let p=0;p<e.length;p++)u[p]=p;this.writeMany(u,o)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q{get id(){return this.idTensor.id}constructor(e,t,s,n=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,e!=null&&e.forEach(i=>{if(s!==i.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${i.dtype}`);V(t,i.shape,"TensorList shape mismatch: "),P(i)}),this.idTensor=q(0),this.maxNumElements=n,P(this.idTensor)}copy(){return new Q([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);V(e,this.elementShape,"TensorList shape mismatch: ");const n=M(this.elementShape,this.tensors,e);return E(()=>{const i=this.tensors.map(o=>k(o,n));return te(i,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=M(this.elementShape,this.tensors,e),n=this.tensors.pop();return n.kept=!1,V(n.shape,e,"TensorList shape mismatch: "),k(n,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(V(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");P(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new Q([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)t.tensors[s]=this.tensors[s];return t}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);V(this.tensors[e].shape,t,"TensorList shape mismatch: ");const n=M(this.elementShape,this.tensors,t);return k(this.tensors[e],n)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);V(this.elementShape,t.shape,"TensorList shape mismatch: "),P(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);V(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const n=M(this.elementShape,this.tensors,s);return e.length===0?ae([],[0].concat(n)):E(()=>{const i=e.map(o=>k(this.tensors[o],n));return te(i,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);V(this.elementShape,t,"TensorList shape mismatch: ");const s=M(this.elementShape,this.tensors,t);return this.size()===0?ae([],[0].concat(s)):E(()=>{const n=this.tensors.map(i=>k(i,s));return ee(n,0)})}}function Fn(a,e,t){const s=a.dtype;if(a.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${a.shape}`);if(a.dtype!==t)throw new Error(`Invalid data types; op elements ${a.dtype}, but list elements ${t}`);const n=a.shape.slice(1);V(n,e,"TensorList shape mismatch: ");const i=re(a);return new Q(i,e,s)}function Rn(a,e,t,s){return new Q([],a,e,s)}function Pn(a,e,t,s){if(e.length!==a.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${a.shape[0]}`);const n=Math.max(...e);if(s!=null&&s!==-1&&n>=s)throw new Error(`Max index must be < array size (${n}  vs. ${s})`);const i=new Q([],t,a.dtype,s),o=re(a,0);return e.forEach((u,p)=>{i.setItem(u,o[p])}),i}function $n(a,e,t){let s=0;const n=e.map(m=>(s+=m,s));if(s!==a.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${a.shape}`);const i=a.shape.slice(1),o=ze(i,t),u=s===0?0:a.size/s,p=E(()=>{const m=[];a=k(a,[1,s,u]);for(let c=0;c<e.length;++c){const h=[0,c===0?0:n[c-1],0],f=[1,e[c],u];m[c]=k(I(a,h,f),o)}return a.dispose(),m}),l=new Q([],t,a.dtype,e.length);for(let m=0;m<p.length;m++)l.setItem(m,p[m]);return l}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jn=async(a,e,t)=>{switch(a.op){case"If":case"StatelessIf":{const s=r("thenBranch",a,e,t),n=r("elseBranch",a,e,t),i=r("cond",a,e,t),o=r("args",a,e,t);return(await i.data())[0]?t.functionMap[s].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap):t.functionMap[n].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const s=r("body",a,e,t),n=r("cond",a,e,t),i=r("args",a,e,t),o=await t.functionMap[n].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap),u=i.map(m=>m.id);let p=await o[0].data();o.forEach(m=>{!m.kept&&u.indexOf(m.id)===-1&&m.dispose()});let l=i;for(;p[0];){const m=l;l=await t.functionMap[s].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);const c=l.map(h=>h.id);m.forEach(h=>{!h.kept&&u.indexOf(h.id)===-1&&c.indexOf(h.id)===-1&&h.dispose()});const d=await t.functionMap[n].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);p=await d[0].data(),d.forEach(h=>{!h.kept&&u.indexOf(h.id)===-1&&c.indexOf(h.id)===-1&&h.dispose()})}return l}case"LoopCond":{const s=r("pred",a,e,t);return[R(s)]}case"Switch":{const s=r("pred",a,e,t);let n=r("data",a,e,t);return n.kept||(n=R(n)),(await s.data())[0]?[void 0,n]:[n,void 0]}case"Merge":{const s=a.inputNames.find(n=>O(n,e,t)!==void 0);if(s){const n=O(s,e,t);return[R(n)]}return}case"Enter":{const s=r("frameName",a,e,t),n=r("tensor",a,e,t);return t.enterFrame(s),[R(n)]}case"Exit":{const s=r("tensor",a,e,t);return t.exitFrame(),[R(s)]}case"NextIteration":{const s=r("tensor",a,e,t);return t.nextIteration(),[R(s)]}case"TensorArrayV3":{const s=r("size",a,e,t),n=r("dtype",a,e,t),i=r("elementShape",a,e,t),o=r("dynamicSize",a,e,t),u=r("clearAfterRead",a,e,t),p=r("identicalElementShapes",a,e,t),l=r("name",a,e,t),m=new xn(l,n,s,i,p,o,u);return t.addTensorArray(m),[m.idTensor,q(1)]}case"TensorArrayWriteV3":{const s=r("tensorArrayId",a,e,t),n=r("index",a,e,t),i=r("tensor",a,e,t),o=t.getTensorArray(s.id);return o.write(n,i),[o.idTensor]}case"TensorArrayReadV3":{const s=r("tensorArrayId",a,e,t),n=r("index",a,e,t);return[t.getTensorArray(s.id).read(n)]}case"TensorArrayGatherV3":{const s=r("tensorArrayId",a,e,t),n=r("indices",a,e,t),i=r("dtype",a,e,t);return[t.getTensorArray(s.id).gather(n,i)]}case"TensorArrayScatterV3":{const s=r("tensorArrayId",a,e,t),n=r("indices",a,e,t),i=r("tensor",a,e,t),o=t.getTensorArray(s.id);return o.scatter(n,i),[o.idTensor]}case"TensorArrayConcatV3":{const s=r("tensorArrayId",a,e,t),n=t.getTensorArray(s.id),i=r("dtype",a,e,t);return[n.concat(i)]}case"TensorArraySplitV3":{const s=r("tensorArrayId",a,e,t),n=r("tensor",a,e,t),i=r("lengths",a,e,t),o=t.getTensorArray(s.id);return o.split(i,n),[o.idTensor]}case"TensorArraySizeV3":{const s=r("tensorArrayId",a,e,t),n=t.getTensorArray(s.id);return[q(n.size(),"int32")]}case"TensorArrayCloseV3":{const s=r("tensorArrayId",a,e,t),n=t.getTensorArray(s.id);return n.clearAndClose(),[n.idTensor]}case"TensorListSetItem":{const s=r("tensorListId",a,e,t),n=r("index",a,e,t),i=r("tensor",a,e,t),o=t.getTensorList(s.id);return o.setItem(n,i),[o.idTensor]}case"TensorListGetItem":{const s=r("tensorListId",a,e,t),n=r("index",a,e,t),i=r("elementShape",a,e,t),o=r("elementDType",a,e,t);return[t.getTensorList(s.id).getItem(n,i,o)]}case"TensorListScatterV2":case"TensorListScatter":{const s=r("indices",a,e,t),n=r("tensor",a,e,t),i=r("elementShape",a,e,t),o=r("numElements",a,e,t),u=Pn(n,s,i,o);return t.addTensorList(u),[u.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=r("elementShape",a,e,t),n=r("elementDType",a,e,t);let i;a.op==="TensorListReserve"?i="numElements":i="maxNumElements";const o=r(i,a,e,t),u=a.op==="TensorListReserve"?-1:o,p=Rn(s,n,o,u);return t.addTensorList(p),[p.idTensor]}case"TensorListGather":{const s=r("tensorListId",a,e,t),n=r("indices",a,e,t),i=r("elementShape",a,e,t),o=r("elementDType",a,e,t);return[t.getTensorList(s.id).gather(n,o,i)]}case"TensorListStack":{const s=r("tensorListId",a,e,t),n=r("elementShape",a,e,t),i=r("elementDType",a,e,t),o=r("numElements",a,e,t);return[t.getTensorList(s.id).stack(n,i,o)]}case"TensorListFromTensor":{const s=r("tensor",a,e,t),n=r("elementShape",a,e,t),i=r("elementDType",a,e,t),o=Fn(s,n,i);return t.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=r("tensorListId",a,e,t),n=t.getTensorList(s.id),i=r("dtype",a,e,t),o=r("elementShape",a,e,t);return[n.concat(i,o)]}case"TensorListPushBack":{const s=r("tensorListId",a,e,t),n=r("tensor",a,e,t),i=t.getTensorList(s.id);return i.pushBack(n),[i.idTensor]}case"TensorListPopBack":{const s=r("tensorListId",a,e,t),n=r("elementShape",a,e,t),i=r("elementDType",a,e,t);return[t.getTensorList(s.id).popBack(n,i)]}case"TensorListSplit":{const s=r("tensor",a,e,t),n=r("elementShape",a,e,t),i=r("lengths",a,e,t),o=$n(s,i,n);return t.addTensorList(o),[o.idTensor]}case"TensorListLength":{const s=r("tensorListId",a,e,t),n=t.getTensorList(s.id);return[q(n.size(),"int32")]}case"TensorListResize":{const s=r("tensorListId",a,e,t),n=r("size",a,e,t),o=t.getTensorList(s.id).resize(n);return t.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function He(a,e,t){const[s,n]=r("fusedOps",a,e,t),i=s==="biasadd",o=!i,u=n==="prelu",p=s==="fusedbatchnorm",l=r("numArgs",a,e,t);if(i){if(u&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!u&&i&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(p)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const m=r("strides",a,e,t),c=oe(a,e,t),d=r("dataFormat",a,e,t).toUpperCase(),h=r("dilations",a,e,t);let[f,g]=r("args",a,e,t);o&&(g=f,f=void 0);const y=r("leakyreluAlpha",a,e,t);return{stride:m,pad:c,dataFormat:d,dilations:h,biasArg:f,preluArg:g,activationFunc:n,leakyreluAlpha:y}}const Bn=(a,e,t,s=v)=>{switch(a.op){case"Conv1D":{const n=r("stride",a,e,t),i=r("pad",a,e,t),o=r("dataFormat",a,e,t).toUpperCase(),u=r("dilation",a,e,t);return[s.conv1d(r("x",a,e,t),r("filter",a,e,t),n,i,o,u)]}case"Conv2D":{const n=r("strides",a,e,t),i=oe(a,e,t),o=r("dataFormat",a,e,t).toUpperCase(),u=r("dilations",a,e,t);return[s.conv2d(r("x",a,e,t),r("filter",a,e,t),[n[1],n[2]],i,o,[u[1],u[2]])]}case"_FusedConv2D":{const{stride:n,pad:i,dataFormat:o,dilations:u,biasArg:p,preluArg:l,activationFunc:m,leakyreluAlpha:c}=He(a,e,t);return[s.fused.conv2d({x:r("x",a,e,t),filter:r("filter",a,e,t),strides:[n[1],n[2]],pad:i,dataFormat:o,dilations:[u[1],u[2]],bias:p,activation:m,preluActivationWeights:l,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{const{stride:n,pad:i,dataFormat:o,dilations:u,biasArg:p,preluArg:l,activationFunc:m,leakyreluAlpha:c}=He(a,e,t);return[s.fused.depthwiseConv2d({x:r("x",a,e,t),filter:r("filter",a,e,t),strides:[n[1],n[2]],pad:i,dataFormat:o,dilations:[u[1],u[2]],bias:p,activation:m,preluActivationWeights:l,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const n=r("outputShape",a,e,t),i=r("strides",a,e,t),o=oe(a,e,t);return[s.conv2dTranspose(r("x",a,e,t),r("filter",a,e,t),n,[i[1],i[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const n=r("strides",a,e,t),i=oe(a,e,t),o=r("dilations",a,e,t),u=r("dataFormat",a,e,t).toUpperCase();return[s.depthwiseConv2d(r("input",a,e,t),r("filter",a,e,t),[n[1],n[2]],i,u,[o[1],o[2]])]}case"Conv3D":{const n=r("strides",a,e,t),i=r("pad",a,e,t),o=r("dataFormat",a,e,t).toUpperCase(),u=r("dilations",a,e,t);return[s.conv3d(r("x",a,e,t),r("filter",a,e,t),[n[1],n[2],n[3]],i,o,[u[1],u[2],u[3]])]}case"AvgPool":{const n=r("strides",a,e,t),i=r("pad",a,e,t),o=r("kernelSize",a,e,t);return[s.avgPool(r("x",a,e,t),[o[1],o[2]],[n[1],n[2]],i)]}case"MaxPool":{const n=r("strides",a,e,t),i=r("pad",a,e,t),o=r("kernelSize",a,e,t);return[s.maxPool(r("x",a,e,t),[o[1],o[2]],[n[1],n[2]],i)]}case"MaxPoolWithArgmax":{const n=r("strides",a,e,t),i=r("pad",a,e,t),o=r("kernelSize",a,e,t),u=r("includeBatchInIndex",a,e,t),{result:p,indexes:l}=s.maxPoolWithArgmax(r("x",a,e,t),[o[1],o[2]],[n[1],n[2]],i,u);return[p,l]}case"AvgPool3D":{const n=r("strides",a,e,t),i=r("pad",a,e,t),o=r("kernelSize",a,e,t);return[s.avgPool3d(r("x",a,e,t),[o[1],o[2],o[3]],[n[1],n[2],n[3]],i)]}case"MaxPool3D":{const n=r("strides",a,e,t),i=r("pad",a,e,t),o=r("kernelSize",a,e,t);return[s.maxPool3d(r("x",a,e,t),[o[1],o[2],o[3]],[n[1],n[2],n[3]],i)]}case"Dilation2D":{const n=r("strides",a,e,t),i=r("pad",a,e,t),o=r("dilations",a,e,t),u=n[1],p=n[2],l=o[1],m=o[2];return[s.dilation2d(r("x",a,e,t),r("filter",a,e,t),[u,p],i,[l,m],"NHWC")]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hn=(a,e,t,s=v)=>{switch(a.op){case"Fill":{const n=r("shape",a,e,t),i=r("dtype",a,e,t),o=r("value",a,e,t);return[s.fill(n,o,i)]}case"LinSpace":{const n=r("start",a,e,t),i=r("stop",a,e,t),o=r("num",a,e,t);return[s.linspace(n,i,o)]}case"Multinomial":{const n=r("logits",a,e,t),i=r("numSamples",a,e,t),o=r("seed",a,e,t);return[s.multinomial(n,i,o)]}case"OneHot":{const n=r("indices",a,e,t),i=r("depth",a,e,t),o=r("onValue",a,e,t),u=r("offValue",a,e,t),p=r("dtype",a,e,t);return[s.oneHot(n,i,o,u,p)]}case"Ones":return[s.ones(r("shape",a,e,t),r("dtype",a,e,t))];case"OnesLike":return[s.onesLike(r("x",a,e,t))];case"RandomStandardNormal":return[s.randomStandardNormal(r("shape",a,e,t),r("dtype",a,e,t),r("seed",a,e,t))];case"RandomUniform":return[s.randomUniform(r("shape",a,e,t),r("minval",a,e,t),r("maxval",a,e,t),r("dtype",a,e,t))];case"RandomUniformInt":return[s.randomUniformInt(r("shape",a,e,t),r("minval",a,e,t),r("maxval",a,e,t),r("seed",a,e,t))];case"Range":{const n=r("start",a,e,t),i=r("stop",a,e,t),o=r("step",a,e,t);return[s.range(n,i,o,r("dtype",a,e,t))]}case"TruncatedNormal":{const n=r("shape",a,e,t),i=r("mean",a,e,t),o=r("stdDev",a,e,t),u=r("seed",a,e,t);return[s.truncatedNormal(n,i,o,r("dtype",a,e,t),u)]}case"Zeros":return[s.zeros(r("shape",a,e,t),r("dtype",a,e,t))];case"ZerosLike":return[s.zerosLike(r("x",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function he(a,e,t){const s=r("boxes",a,e,t),n=r("scores",a,e,t),i=r("maxOutputSize",a,e,t),o=r("iouThreshold",a,e,t),u=r("scoreThreshold",a,e,t),p=r("softNmsSigma",a,e,t);return{boxes:s,scores:n,maxOutputSize:i,iouThreshold:o,scoreThreshold:u,softNmsSigma:p}}const Un=async(a,e,t,s,n=v)=>{switch(a.op){case"NonMaxSuppressionV5":{const{boxes:i,scores:o,maxOutputSize:u,iouThreshold:p,scoreThreshold:l,softNmsSigma:m}=he(a,e,t),c=await n.image.nonMaxSuppressionWithScoreAsync(i,o,u,p,l,m);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:i,scores:o,maxOutputSize:u,iouThreshold:p,scoreThreshold:l}=he(a,e,t),m=r("padToMaxOutputSize",a,e,t),c=await n.image.nonMaxSuppressionPaddedAsync(i,o,u,p,l,m);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:i,scores:o,maxOutputSize:u,iouThreshold:p,scoreThreshold:l}=he(a,e,t);return[await n.image.nonMaxSuppressionAsync(i,o,u,p,l)]}case"Where":{const i=n.cast(r("condition",a,e,t),"bool"),o=[await n.whereAsync(i)];return i.dispose(),o}case"ListDiff":return n.setdiff1dAsync(r("x",a,e,t),r("y",a,e,t));default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qn=(a,e,t,s=v)=>{switch(a.op){case"LowerBound":{const n=r("sortedSequence",a,e,t),i=r("values",a,e,t);return[s.lowerBound(n,i)]}case"TopKV2":{const n=r("x",a,e,t),i=r("k",a,e,t),o=r("sorted",a,e,t),u=s.topk(n,i,o);return[u.values,u.indices]}case"UpperBound":{const n=r("sortedSequence",a,e,t),i=r("values",a,e,t);return[s.upperBound(n,i)]}case"Unique":{const n=r("x",a,e,t),i=s.unique(n);return[i.values,i.indices]}case"UniqueV2":{const n=r("x",a,e,t),i=r("axis",a,e,t),o=s.unique(n,i);return[o.values,o.indices]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wn=(a,e,t,s=v)=>{switch(a.op){case"Const":return e[a.name];case"PlaceholderWithDefault":const n=r("default",a,e,t);return[O(a.name,e,t)||n];case"Placeholder":return[O(a.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const m=r("x",a,e,t);return[R(m)]}case"IdentityN":return r("x",a,e,t).map(m=>R(m));case"Snapshot":const i=r("x",a,e,t);return[R(i)];case"Shape":return[s.tensor1d(r("x",a,e,t).shape,"int32")];case"ShapeN":return r("x",a,e,t).map(m=>s.tensor1d(m.shape));case"Size":return[s.scalar(r("x",a,e,t).size,"int32")];case"Rank":return[s.scalar(r("x",a,e,t).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const o=r("x",a,e,t),u=r("data",a,e,t),p=r("message",a,e,t),l=r("summarize",a,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(p);for(let m=0;m<u.length;m++)console.log(Array.prototype.slice.call(u[m].dataSync()).slice(0,l));return[o];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gn{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=q(0),this.tensorMap=new Map,P(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return q(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return this.tensorMap.forEach(n=>n.dispose()),this.tensorMap.clear(),E(()=>{const n=re(t),i=s.length,o=n.length;K(i===o,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${o} elements.`);for(let u=0;u<i;u++){const p=s[u],l=n[u];P(l),this.tensorMap.set(p,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return E(()=>{const n=[];for(let i=0;i<s.length;i++){const o=s[i],u=this.findWithDefault(o,t);n.push(u)}return te(n)})}findWithDefault(e,t){const s=this.tensorMap.get(e);return s??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kn=async(a,e,t,s)=>{switch(a.op){case"HashTable":case"HashTableV2":{const n=s.getHashTableHandleByName(a.name);if(n!=null)return[n];{const i=r("keyDType",a,e,t),o=r("valueDType",a,e,t),u=new Gn(i,o);return s.addHashTable(a.name,u),[u.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const n=r("tableHandle",a,e,t,s),i=r("keys",a,e,t),o=r("values",a,e,t);return[await s.getHashTableById(n.id).import(i,o)]}case"LookupTableFind":case"LookupTableFindV2":{const n=r("tableHandle",a,e,t,s),i=r("keys",a,e,t),o=r("defaultValue",a,e,t);return[await s.getHashTableById(n.id).find(i,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const n=r("tableHandle",a,e,t,s);return[s.getHashTableById(n.id).tensorSize()]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qn=(a,e,t,s=v)=>{switch(a.op){case"ResizeBilinear":{const n=r("images",a,e,t),i=r("size",a,e,t),o=r("alignCorners",a,e,t),u=r("halfPixelCenters",a,e,t);return[s.image.resizeBilinear(n,[i[0],i[1]],o,u)]}case"ResizeNearestNeighbor":{const n=r("images",a,e,t),i=r("size",a,e,t),o=r("alignCorners",a,e,t),u=r("halfPixelCenters",a,e,t);return[s.image.resizeNearestNeighbor(n,[i[0],i[1]],o,u)]}case"CropAndResize":{const n=r("image",a,e,t),i=r("boxes",a,e,t),o=r("boxInd",a,e,t),u=r("cropSize",a,e,t),p=r("method",a,e,t),l=r("extrapolationValue",a,e,t);return[s.image.cropAndResize(n,i,o,u,p,l)]}case"ImageProjectiveTransformV3":{const n=r("images",a,e,t),i=r("transforms",a,e,t),o=r("outputShape",a,e,t),u=r("fillValue",a,e,t),p=r("interpolation",a,e,t),l=r("fillMode",a,e,t);return[s.image.transform(n,i,p.toLowerCase(),l.toLowerCase(),u,o)]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xn=(a,e,t,s=v)=>{switch(a.op){case"Equal":return[s.equal(r("a",a,e,t),r("b",a,e,t))];case"NotEqual":return[s.notEqual(r("a",a,e,t),r("b",a,e,t))];case"Greater":return[s.greater(r("a",a,e,t),r("b",a,e,t))];case"GreaterEqual":return[s.greaterEqual(r("a",a,e,t),r("b",a,e,t))];case"Less":return[s.less(r("a",a,e,t),r("b",a,e,t))];case"LessEqual":return[s.lessEqual(r("a",a,e,t),r("b",a,e,t))];case"LogicalAnd":return[s.logicalAnd(r("a",a,e,t),r("b",a,e,t))];case"LogicalNot":return[s.logicalNot(r("a",a,e,t))];case"LogicalOr":return[s.logicalOr(r("a",a,e,t),r("b",a,e,t))];case"Select":case"SelectV2":return[s.where(r("condition",a,e,t),r("a",a,e,t),r("b",a,e,t))];case"BitwiseAnd":return[s.bitwiseAnd(r("a",a,e,t),r("b",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yn=(a,e,t,s=v)=>{switch(a.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(r("a",a,e,t),r("b",a,e,t),r("transposeA",a,e,t),r("transposeB",a,e,t))];case"Einsum":return[s.einsum(r("equation",a,e,t),...r("tensors",a,e,t))];case"Transpose":return[s.transpose(r("x",a,e,t),r("perm",a,e,t))];case"_FusedMatMul":const[n,i]=r("fusedOps",a,e,t),o=n==="biasadd",u=i==="prelu",p=r("numArgs",a,e,t),l=r("leakyreluAlpha",a,e,t);if(o){if(u&&p!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!u&&p!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[m,c]=r("args",a,e,t);return[s.fused.matMul({a:r("a",a,e,t),b:r("b",a,e,t),transposeA:r("transposeA",a,e,t),transposeB:r("transposeB",a,e,t),bias:m,activation:i,preluActivationWeights:c,leakyreluAlpha:l})];case"MatrixBandPart":return[s.linalg.bandPart(r("a",a,e,t),r("numLower",a,e,t),r("numUpper",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zn=(a,e,t,s=v)=>{switch(a.op){case"EuclideanNorm":return[s.euclideanNorm(r("x",a,e,t),r("axis",a,e,t),r("keepDims",a,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(r("x",a,e,t),r("mean",a,e,t),r("variance",a,e,t),r("offset",a,e,t),r("scale",a,e,t),r("epsilon",a,e,t))];case"FusedBatchNormV3":return[s.batchNorm(r("x",a,e,t),r("mean",a,e,t),r("variance",a,e,t),r("offset",a,e,t),r("scale",a,e,t),r("epsilon",a,e,t))];case"LRN":return[s.localResponseNormalization(r("x",a,e,t),r("radius",a,e,t),r("bias",a,e,t),r("alpha",a,e,t),r("beta",a,e,t))];case"Softmax":return[s.softmax(r("x",a,e,t))];case"LogSoftmax":return[s.logSoftmax(r("x",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jn=(a,e,t,s=v)=>{switch(a.op){case"RaggedGather":{const{outputNestedSplits:n,outputDenseValues:i}=s.raggedGather(r("paramsNestedSplits",a,e,t),r("paramsDenseValues",a,e,t),r("indices",a,e,t),r("outputRaggedRank",a,e,t));return n.concat(i)}case"RaggedRange":{const{rtNestedSplits:n,rtDenseValues:i}=s.raggedRange(r("starts",a,e,t),r("limits",a,e,t),r("splits",a,e,t));return[n,i]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(r("shape",a,e,t),r("values",a,e,t),r("defaultValue",a,e,t),r("rowPartitionTensors",a,e,t),r("rowPartitionTypes",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mn=(a,e,t,s=v)=>{switch(a.op){case"Max":{const u=r("axis",a,e,t),p=r("keepDims",a,e,t);return[s.max(r("x",a,e,t),u,p)]}case"Mean":{const u=r("axis",a,e,t),p=r("keepDims",a,e,t);return[s.mean(r("x",a,e,t),u,p)]}case"Min":{const u=r("axis",a,e,t),p=r("keepDims",a,e,t);return[s.min(r("x",a,e,t),u,p)]}case"Sum":{const u=r("axis",a,e,t),p=r("keepDims",a,e,t);return[s.sum(r("x",a,e,t),u,p)]}case"All":{const u=r("axis",a,e,t),p=r("keepDims",a,e,t);return[s.all(r("x",a,e,t),u,p)]}case"Any":{const u=r("axis",a,e,t),p=r("keepDims",a,e,t);return[s.any(r("x",a,e,t),u,p)]}case"ArgMax":{const u=r("axis",a,e,t);return[s.argMax(r("x",a,e,t),u)]}case"ArgMin":{const u=r("axis",a,e,t);return[s.argMin(r("x",a,e,t),u)]}case"Prod":{const u=r("axis",a,e,t),p=r("keepDims",a,e,t);return[s.prod(r("x",a,e,t),u,p)]}case"Cumprod":{const u=r("axis",a,e,t),p=r("exclusive",a,e,t),l=r("reverse",a,e,t);return[s.cumprod(r("x",a,e,t),u,p,l)]}case"Cumsum":{const u=r("axis",a,e,t),p=r("exclusive",a,e,t),l=r("reverse",a,e,t);return[s.cumsum(r("x",a,e,t),u,p,l)]}case"Bincount":const n=r("x",a,e,t),i=r("weights",a,e,t),o=r("size",a,e,t);return[s.bincount(n,i,o)];case"DenseBincount":{const u=r("x",a,e,t),p=r("weights",a,e,t),l=r("size",a,e,t),m=r("binaryOutput",a,e,t);return[s.denseBincount(u,p,l,m)]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ei=(a,e,t,s=v)=>{switch(a.op){case"ConcatV2":case"Concat":{const n=r("n",a,e,t),i=r("axis",a,e,t);let o=r("tensors",a,e,t);return o=o.slice(0,n),[s.concat(o,i)]}case"Gather":{const n=r("x",a,e,t),i=r("indices",a,e,t);return[s.gather(n,s.cast(i,"int32"),0)]}case"GatherV2":{const n=r("axis",a,e,t),i=r("batchDims",a,e,t),o=r("x",a,e,t),u=r("indices",a,e,t);return[s.gather(o,s.cast(u,"int32"),n,i)]}case"Reverse":{const n=r("dims",a,e,t),i=[];for(let u=0;u<n.length;u++)n[u]&&i.push(u);const o=r("x",a,e,t);return[s.reverse(o,i)]}case"ReverseV2":{const n=r("axis",a,e,t),i=r("x",a,e,t);return[s.reverse(i,n)]}case"Slice":{const n=r("begin",a,e,t),i=r("size",a,e,t);return[s.slice(r("x",a,e,t),n,i)]}case"StridedSlice":{const n=r("begin",a,e,t),i=r("end",a,e,t),o=r("strides",a,e,t),u=r("beginMask",a,e,t),p=r("endMask",a,e,t),l=r("ellipsisMask",a,e,t),m=r("newAxisMask",a,e,t),c=r("shrinkAxisMask",a,e,t),d=r("x",a,e,t);return[s.stridedSlice(d,n,i,o,u,p,l,m,c)]}case"Pack":return E(()=>{const n=r("axis",a,e,t),i=r("tensors",a,e,t),o=i[0].shape,u=s.squeeze(i[0]).shape,p=i.map(l=>{const m=Fe(l.shape,o);if(!m&&!Fe(s.squeeze(l).shape,u))throw new Error("the input tensors shape does not match");return m?l:s.reshape(l,o)});return[s.stack(p,n)]});case"Unpack":{const n=r("axis",a,e,t),i=r("tensor",a,e,t);return s.unstack(i,n)}case"Tile":{const n=r("reps",a,e,t);return[s.tile(r("x",a,e,t),n)]}case"Split":case"SplitV":{const n=r("axis",a,e,t),i=r("numOrSizeSplits",a,e,t),o=r("x",a,e,t);return s.split(o,i,n)}case"ScatterNd":{const n=r("indices",a,e,t),i=r("values",a,e,t),o=r("shape",a,e,t);return[s.scatterND(n,i,o)]}case"GatherNd":{const n=r("x",a,e,t),i=r("indices",a,e,t);return[s.gatherND(n,i)]}case"SparseToDense":{const n=r("sparseIndices",a,e,t),i=r("outputShape",a,e,t),o=r("sparseValues",a,e,t),u=r("defaultValue",a,e,t);return[s.sparseToDense(n,o,i,o.dtype===u.dtype?u:s.cast(u,o.dtype))]}case"TensorScatterUpdate":{const n=r("indices",a,e,t),i=r("values",a,e,t),o=r("tensor",a,e,t);return[s.tensorScatterUpdate(o,n,i)]}default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ti=(a,e,t,s=v)=>{switch(a.op){case"SparseFillEmptyRows":{const{outputIndices:n,outputValues:i,emptyRowIndicator:o,reverseIndexMap:u}=s.sparse.sparseFillEmptyRows(r("indices",a,e,t),r("values",a,e,t),r("denseShape",a,e,t),r("defaultValue",a,e,t));return[n,i,o,u]}case"SparseReshape":{const{outputIndices:n,outputShape:i}=s.sparse.sparseReshape(r("inputIndices",a,e,t),r("inputShape",a,e,t),r("newShape",a,e,t));return[n,i]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(r("data",a,e,t),r("indices",a,e,t),r("segmentIds",a,e,t))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(r("data",a,e,t),r("indices",a,e,t),r("segmentIds",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ai=(a,e,t,s=v)=>{switch(a.op){case"FFT":return[s.fft(r("x",a,e,t))];case"IFFT":return[s.ifft(r("x",a,e,t))];case"RFFT":return[s.rfft(r("x",a,e,t))];case"IRFFT":return[s.irfft(r("x",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const si=(a,e,t,s=v)=>{switch(a.op){case"StaticRegexReplace":return[s.string.staticRegexReplace(r("input",a,e,t),r("pattern",a,e,t),r("rewrite",a,e,t),r("replaceGlobal",a,e,t))];case"StringNGrams":{const{nGrams:n,nGramsSplits:i}=s.string.stringNGrams(r("data",a,e,t),r("dataSplits",a,e,t),r("separator",a,e,t),r("nGramWidths",a,e,t),r("leftPad",a,e,t),r("rightPad",a,e,t),r("padWidth",a,e,t),r("preserveShortSequences",a,e,t));return[n,i]}case"StringSplit":{const{indices:n,values:i,shape:o}=s.string.stringSplit(r("input",a,e,t),r("delimiter",a,e,t),r("skipEmpty",a,e,t));return[n,i,o]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(r("input",a,e,t),r("numBuckets",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ri=(a,e,t,s=v)=>{switch(a.op){case"Cast":return[s.cast(r("x",a,e,t),r("dtype",a,e,t))];case"ExpandDims":{const n=r("axis",a,e,t);return[s.expandDims(r("x",a,e,t),n)]}case"Squeeze":{const n=r("axis",a,e,t);return[s.squeeze(r("x",a,e,t),n)]}case"Reshape":return[s.reshape(r("x",a,e,t),r("shape",a,e,t))];case"EnsureShape":return[s.ensureShape(r("x",a,e,t),r("shape",a,e,t))];case"MirrorPad":return[s.mirrorPad(r("x",a,e,t),r("padding",a,e,t),r("mode",a,e,t))];case"PadV2":case"Pad":return[s.pad(r("x",a,e,t),r("padding",a,e,t),r("constantValue",a,e,t))];case"SpaceToBatchND":{const n=r("blockShape",a,e,t),i=r("paddings",a,e,t);return[s.spaceToBatchND(r("x",a,e,t),n,i)]}case"BatchToSpaceND":{const n=r("blockShape",a,e,t),i=r("crops",a,e,t);return[s.batchToSpaceND(r("x",a,e,t),n,i)]}case"DepthToSpace":{const n=r("blockSize",a,e,t),i=r("dataFormat",a,e,t).toUpperCase();return[s.depthToSpace(r("x",a,e,t),n,i)]}case"BroadcastTo":return[s.broadcastTo(r("x",a,e,t),r("shape",a,e,t))];case"BroadcastArgs":return[s.broadcastArgs(r("s0",a,e,t),r("s1",a,e,t))];default:throw TypeError(`Node type ${a.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ue(a,e,t,s,n=E){const i=((o,u,p)=>{switch(o.category){case"arithmetic":return n(()=>Cn(o,u,p));case"basic_math":return n(()=>Vn(o,u,p));case"control":return jn(o,u,p);case"convolution":return n(()=>Bn(o,u,p));case"creation":return n(()=>Hn(o,u,p));case"dynamic":return Un(o,u,p);case"evaluation":return n(()=>qn(o,u,p));case"image":return n(()=>Qn(o,u,p));case"graph":return n(()=>Wn(o,u,p));case"logical":return n(()=>Xn(o,u,p));case"matrices":return n(()=>Yn(o,u,p));case"normalization":return n(()=>Zn(o,u,p));case"ragged":return n(()=>Jn(o,u,p));case"reduction":return n(()=>Mn(o,u,p));case"slice_join":return n(()=>ei(o,u,p));case"sparse":return n(()=>ti(o,u,p));case"spectral":return n(()=>ai(o,u,p));case"string":return n(()=>si(o,u,p));case"transformation":return n(()=>ri(o,u,p));case"hash_table":return Kn(o,u,p,s);case"custom":const l=Me(o.op);if(l&&l.customExecutor)return l.customExecutor(new Dn(o,u,p));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(a,e,t);return me(i)?i.then(o=>[].concat(o)):[].concat(i)}class qe{constructor(e={},t={},s={},n={},i){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=s,this.functionMap=n,this.parseNodeNameCache=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const s=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function We(a,e,t,s){const n=new Set,i=[];let o=null,u=null;const p=new Set,l=new Set(Object.keys(a).map(d=>L(d)[0]));s=s||[];const m=new Set(s.map(d=>L(d.name)[0])),c=[...e];for(;c.length>0;){const d=c.pop();if((G(d)||ci(d)||di(d))&&o==null&&(o=d,u=o.children.map(h=>h.name).filter(h=>n.has(h))),n.add(d.name),t[d.name]==null&&!l.has(d.name)&&!m.has(d.name)){if(d.inputs.length===0){i.push(d.name);continue}d.inputs.forEach(h=>{p.has(h.name)||(p.add(h.name),c.push(h))})}}return{inputs:a,outputs:e,usedNodes:n,missingInputs:i,dynamicNode:o,syncInputs:u}}function ni(a,e){const{usedNodes:t,inputs:s}=e,n=Object.keys(s).map(y=>L(y)[0]).map(y=>a.nodes[y]),i=a.initNodes||[],o=y=>t.has(typeof y=="string"?y:y.name);function u(y){return[...new Map(y.map(N=>[N.name,N])).values()]}const p=u([...n,...a.weights,...i]).filter(o),l=u([...p,...Object.values(a.nodes)]).filter(o),m=new Map(l.map(y=>[y.name,y])),c={};for(const y of l){c[y.name]=c[y.name]||0;for(const N of y.children)o(N)||(c[N.name]=Number.POSITIVE_INFINITY),c[N.name]=(c[N.name]||0)+1}const d=Object.entries(c).filter(([,y])=>y===0).map(([y])=>y),h=[...d];for(;d.length>0;){const y=d.pop(),N=m.get(y);for(const T of N.children.filter(o))--c[T.name]===0&&(h.push(T.name),d.push(T.name))}const f=h.map(y=>m.get(y)),g=ii(f,p);return ui(g,p),g}function ii(a,e){const t=new Map(a.map(o=>[o.name,o])),s=e.map(o=>o.name),n=new Set(s);for(;s.length>0;){const o=s.pop(),u=t.get(o);for(const p of u.children)!t.has(p.name)||n.has(p.name)||(n.add(p.name),s.push(p.name))}return a.filter(o=>n.has(o.name))}class ue extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function ui(a,e){const t=new Map(a.map((u,p)=>[u.name,p])),s=new Set(e.map(u=>u.name)),n=u=>s.has(typeof u=="string"?u:u.name),i=new Set(a.map(u=>u.name)),o=u=>i.has(typeof u=="string"?u:u.name);for(const u of a){for(const p of u.children.filter(o)){if(!t.has(p.name))throw new ue(`Child ${p.name} of node ${u.name} is unreachable.`);if(t.get(u.name)>t.get(p.name))throw new ue(`Node ${u.name} is scheduled to run after its child ${p.name}.`)}if(!n(u))for(const p of u.inputs){if(!t.has(p.name))throw new ue(`Input ${p.name} of node ${u.name} is unreachable.`);if(t.get(p.name)>t.get(u.name))throw new ue(`Node ${u.name} is scheduled to run before its input ${p.name}.`)}}}function oi(a){const e=new Map(a.map((u,p)=>[u.name,p])),t=Number.MAX_SAFE_INTEGER,s=a.map((u,p)=>G(u)?t:p),n=u=>{const p=s[e.get(u.name)];return p??-1},i=a.map((u,p)=>u.children.map(n).reduce((l,m)=>Math.max(l,m),s[p])),o=new Map;for(let u=0;u<a.length;++u){const p=i[u];if(p===t)continue;const l=a[u],m=a[p];o.has(m.name)||o.set(m.name,[]),o.get(m.name).push(l)}return o}const pi=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),mi=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),li=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function G(a){return pi.has(a.op)}function ci(a){return mi.has(a.op)}function di(a){return li.has(a.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ce{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(s=>e[s].map(n=>n.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new ce(e.functions[s],this)})}getCompilationKey(e,t){const s=e.map(i=>i.name).sort(),n=t.map(i=>i.name).sort();return s.join(this.SEPARATOR)+"--"+n.join(this.SEPARATOR)}compile(e,t){const s=We(e,t,this.weightMap,this._initNodes),{missingInputs:n,dynamicNode:i,syncInputs:o}=s;if(i!=null)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(n.length>0){const l=t.map(c=>c.name),m=Object.keys(e);throw new Error(`Cannot compute the outputs [${l}] from the provided inputs [${m}]. Missing the following inputs: [${n}]`)}const u=ni(this.graph,s),p=oi(u);return{orderedNodes:u,nodeLiveUntilMap:p}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return P(t),t}cloneTensorList(e){return e?e.map(s=>this.cloneAndKeepTensor(s)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,s])=>[t,this.cloneTensorList(s)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const n=s.map(d=>this.graph.nodes[L(d)[0]]),i=t.map(d=>L(d)[0]),o=new Set(i);let u=i.map(d=>this.graph.nodes[d]);u.length===0&&(u=this._outputs);const p=this.getCompilationKey(n,u);let l=this.compiledMap.get(p);l==null&&(l=this.compile(e,u),this.compiledMap.set(p,l));try{this.keepIntermediateTensors=pe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const m={},c={};return E(()=>{const d=new qe(this.weightMap,m,c,this.functionExecutorMap,this.parseNodeNameCache),h=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(N=>{const[T,w]=L(N,d),b=[];b[w]=e[N],h[T]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[T]=this.cloneTensorList(b))});const f=this.getFrozenTensorIds(h),{orderedNodes:g,nodeLiveUntilMap:y}=l;for(const N of g){if(h[N.name])continue;const T=Ue(N,h,d,this._resourceManager);if(me(T))throw new Error(`The execution of the op '${N.op}' returned a promise. Please use model.executeAsync() instead.`);h[N.name]=T,this.keepIntermediateTensors&&(this.clonedTensorsMap[N.name]=this.cloneTensorList(T)),this.checkTensorForDisposalWithNodeLiveUntilInfo(N,h,d,f,o,y.get(N.name))}return this.parent==null&&d.dispose(f),t.map(N=>O(N,h,d))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(n=>n.id)));return new Set(t)}checkTensorForDisposal(e,t,s,n,i,o,u){if(!(G(t)||o.has(e))){for(const p of s[e])p!=null&&(u[p.id]=(u[p.id]||0)+t.children.length);for(const p of t.inputs){if(G(p))continue;const l=Pe(p.name,s,n);if(l!=null)for(const m of l){if(!m||m.kept||i.has(m.id))continue;const c=u[m.id];c===1?(m.dispose(),delete u[m.id]):c!=null&&u[m.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,s,n,i,o){function u(p){return G(p)||i.has(p.name)}if(!(G(e)||o==null))for(const p of o){if(u(p))continue;const l=Pe(p.name,t,s);for(const m of l)!m||m.kept||n.has(m.id)||m.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,s=!1,n={},i={}){this.disposeIntermediateTensors(),s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=pe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const o=new qe(this.weightMap,n,i,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const u=await this.executeWithControlFlow(e,o,t,s),p=t.map(d=>O(d,u,o)),l=p.map(d=>d.id),m=Object.keys(e).map(d=>e[d].id),c=new Set([...l,...m,...this.weightIds]);return Object.values(u).forEach(d=>{d.forEach(h=>{h&&!h.isDisposed&&!c.has(h.id)&&h.dispose()})}),this.parent==null&&o.dispose(c),p}async executeFunctionAsync(e,t,s){const n=e.reduce((i,o,u)=>(i[this.inputs[u].name]=o,i),{});return this._executeAsync(n,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,t,s,n){const i=Object.keys(e),o=i.map(b=>this.graph.nodes[L(b)[0]]),u=s.map(b=>L(b)[0]),p=new Set(u);let l=u.map(b=>this.graph.nodes[b]);l.length===0&&(l=this._outputs);const{usedNodes:m,missingInputs:c,dynamicNode:d,syncInputs:h}=We(e,l,this.weightMap,this._initNodes),f=[...o,...this.graph.weights,...this._initNodes||[]].map(b=>({node:b,contexts:t.currentContext})),g=Object.assign({},this.weightMap);Object.keys(e).forEach(b=>{const[S,_]=L(b),D=[];D[_]=e[b],g[S]=D});const y={},N=this.getFrozenTensorIds(g),T={};for(;f.length>0;){const b=this.processStack(o,f,t,g,T,N,p,y,m);await Promise.all(b)}d==null&&!n&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const w=l.filter(b=>!G(b)&&!O(b.name,g,t)).map(b=>b.name);if(w.length>0){let b="";throw d!=null&&(b=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`),new Error(`Cannot compute the outputs [${w}] from the provided inputs [${i}]. Consider providing the following inputs: [${c}]. ${b}`)}return g}processStack(e,t,s,n,i,o,u,p,l){const m=[];for(;t.length>0;){const c=t.pop();s.currentContext=c.contexts;let d="";if(c.node.op==="Enter"&&r("isConstant",c.node,n,s)&&([d]=F(c.node.name,s)),n[c.node.name]==null){const h=Ue(c.node,n,s,this._resourceManager);d||([d]=F(c.node.name,s));const f=s.currentContext;me(h)?m.push(h.then(g=>(n[d]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(g)),s.currentContext=f,this.checkTensorForDisposal(d,c.node,n,s,o,u,p),this.processChildNodes(c.node,t,s,n,i,l),g))):(n[d]=h,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(h)),this.checkTensorForDisposal(d,c.node,n,s,o,u,p),this.processChildNodes(c.node,t,s,n,i,l))}else this.processChildNodes(c.node,t,s,n,i,l)}return m}processChildNodes(e,t,s,n,i,o){e.children.forEach(u=>{const[p]=F(u.name,s);i[p]||!o.has(u.name)||(u.op==="Merge"?u.inputNames.some(l=>!!O(l,n,s))&&(i[p]=!0,t.push({contexts:s.currentContext,node:u})):u.inputNames.every(l=>!!O(l,n,s))&&(i[p]=!0,t.push({contexts:s.currentContext,node:u})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const s=e[t],[n]=L(t),i=this.graph.nodes[n];if(i.attrParams.shape&&i.attrParams.shape.value){const o=i.attrParams.shape.value,u=o.length===s.shape.length&&s.shape.every((p,l)=>o[l]===-1||o[l]===p);K(u,()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${o}], but was [${s.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&K(s.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){var t,s;const n={};for(const i in e){const o=(s=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||s===void 0?void 0:s[i];o!=null?n[o.name]=e[i]:n[i]=e[i]}return n}checkInputs(e){const t=Object.keys(e).filter(s=>{const[n]=L(s);return this.graph.nodes[n]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var s,n;const i=(n=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||n===void 0?void 0:n[t];return i!=null?i.name:t},{})}checkOutputs(e){e.forEach(t=>{const[s]=L(t);if(!this.graph.nodes[s])throw new Error(`The output '${t}' is not found in the graph`)})}}class hi{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yi="?tfjs-format=file",fi="model.json";class gi{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},s=Je){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=s,t==null&&(this.loadOptions={}),this.resourceManager=new hi}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return me(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const t=await Br(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const s=this.artifacts.modelTopology;let n=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const i=this.artifacts.userDefinedMetadata;i.signature!=null&&(n=i.signature),i.structuredOutputKeys!=null&&(this.structuredOutputKeys=i.structuredOutputKeys)}if(this.signature=n,this.version=`${s.versions.producer}.${s.versions.minConsumer}`,this.executor=new ce($e.Instance.transformGraph(s,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const i=$e.Instance.transformGraph(e.modelInitializer);this.initializer=new ce(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const s=this.io.getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof se?[e]:e,s={};return t.forEach((n,i)=>s[this.structuredOutputKeys[i]]=n),s}return e}predict(e,t){const s=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(e,t){const s=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(e){var t;if(!(e instanceof se)&&!Array.isArray(e)){const i=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(i!=null)for(const o in i){const u=i[o];u.resourceId!=null&&(e[o]=this.resourceIdToCapturedInput[u.resourceId])}return e}e=Array.isArray(e)?e:[e];const s=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${e.length} input tensors provided.`);let n=0;return this.inputNodes.reduce((i,o)=>{var u,p,l;const m=(l=(p=(u=this.signature)===null||u===void 0?void 0:u.inputs)===null||p===void 0?void 0:p[o])===null||l===void 0?void 0:l.resourceId;return m!=null?i[o]=this.resourceIdToCapturedInput[m]:i[o]=e[n++],i},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,s=Object.keys(t);for(let n=0;n<s.length;n++){const i=s[n],o=t[i];this.resourceIdToCapturedInput[o.resourceId]=e[n]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=this.executor.execute(e,t);return s.length>1?s:s[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=await this.executor.executeAsync(e,t);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,s)=>(t[s]=[e[s]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Z(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Ni(a,e={},t=Je){if(a==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof a=="string"&&(a=bi(a));const s=new gi(a,e,t);return await s.load(),s}function bi(a){return a.endsWith("/")||(a=a+"/"),`${a}${fi}${yi}`}/**
    * @license
    * Copyright 2024 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var W=function(){return W=Object.assign||function(a){for(var e,t=1,s=arguments.length;t<s;t++)for(var n in e=arguments[t])Object.prototype.hasOwnProperty.call(e,n)&&(a[n]=e[n]);return a},W.apply(this,arguments)};function $(a,e,t,s){return new(t||(t=Promise))(function(n,i){function o(l){try{p(s.next(l))}catch(m){i(m)}}function u(l){try{p(s.throw(l))}catch(m){i(m)}}function p(l){var m;l.done?n(l.value):(m=l.value,m instanceof t?m:new t(function(c){c(m)})).then(o,u)}p((s=s.apply(a,[])).next())})}function j(a,e){var t,s,n,i,o={label:0,sent:function(){if(1&n[0])throw n[1];return n[1]},trys:[],ops:[]};return i={next:u(0),throw:u(1),return:u(2)},typeof Symbol=="function"&&(i[Symbol.iterator]=function(){return this}),i;function u(p){return function(l){return function(m){if(t)throw new TypeError("Generator is already executing.");for(;o;)try{if(t=1,s&&(n=2&m[0]?s.return:m[0]?s.throw||((n=s.return)&&n.call(s),0):s.next)&&!(n=n.call(s,m[1])).done)return n;switch(s=0,n&&(m=[2&m[0],n.value]),m[0]){case 0:case 1:n=m;break;case 4:return o.label++,{value:m[1],done:!1};case 5:o.label++,s=m[1],m=[0];continue;case 7:m=o.ops.pop(),o.trys.pop();continue;default:if(n=o.trys,!((n=n.length>0&&n[n.length-1])||m[0]!==6&&m[0]!==2)){o=0;continue}if(m[0]===3&&(!n||m[1]>n[0]&&m[1]<n[3])){o.label=m[1];break}if(m[0]===6&&o.label<n[1]){o.label=n[1],n=m;break}if(n&&o.label<n[2]){o.label=n[2],o.ops.push(m);break}n[2]&&o.ops.pop(),o.trys.pop();continue}m=e.call(a,o)}catch(c){m=[6,c],s=0}finally{t=n=0}if(5&m[0])throw m[1];return{value:m[0]?m[1]:void 0,done:!0}}([p,l])}}}var at=["rightEye","leftEye","noseTip","mouthCenter","rightEarTragion","leftEarTragion"],ye={modelType:"short",runtime:"mediapipe",maxFaces:1},Ti=function(){function a(e){var t=this;this.width=0,this.height=0,this.selfieMode=!1,this.faceDetectorSolution=new nt.FaceDetection({locateFile:function(s,n){if(e.solutionPath){var i=e.solutionPath.replace(/\/+$/,"");return"".concat(i,"/").concat(s)}return"".concat(n,"/").concat(s)}}),this.faceDetectorSolution.setOptions({selfieMode:this.selfieMode,model:e.modelType}),this.faceDetectorSolution.onResults(function(s){if(t.height=s.image.height,t.width=s.image.width,t.faces=[],s.detections!==null)for(var n=0,i=s.detections;n<i.length;n++){var o=i[n];t.faces.push(t.normalizedToAbsolute(o.landmarks,(u=o.boundingBox,p=void 0,l=void 0,m=void 0,p=u.xCenter-u.width/2,l=p+u.width,m=u.yCenter-u.height/2,{xMin:p,xMax:l,yMin:m,yMax:m+u.height,width:u.width,height:u.height})))}var u,p,l,m})}return a.prototype.normalizedToAbsolute=function(e,t){var s=this;return{keypoints:e.map(function(n,i){return{x:n.x*s.width,y:n.y*s.height,name:at[i]}}),box:{xMin:t.xMin*this.width,yMin:t.yMin*this.height,xMax:t.xMax*this.width,yMax:t.yMax*this.height,width:t.width*this.width,height:t.height*this.height}}},a.prototype.estimateFaces=function(e,t){return $(this,void 0,void 0,function(){var s,n;return j(this,function(i){switch(i.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.faceDetectorSolution.setOptions({selfieMode:this.selfieMode})),e instanceof se?(n=ImageData.bind,[4,Hr(e)]):[3,2];case 1:return s=new(n.apply(ImageData,[void 0,i.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:s=e,i.label=3;case 3:return e=s,[4,this.faceDetectorSolution.send({image:e})];case 4:return i.sent(),[2,this.faces]}})})},a.prototype.dispose=function(){this.faceDetectorSolution.close()},a.prototype.reset=function(){this.faceDetectorSolution.reset(),this.width=0,this.height=0,this.faces=null,this.selfieMode=!1},a.prototype.initialize=function(){return this.faceDetectorSolution.initialize()},a}();function Si(a){return $(this,void 0,void 0,function(){var e,t;return j(this,function(s){switch(s.label){case 0:return e=function(n){if(n==null)return W({},ye);var i=W({},n);return i.runtime="mediapipe",i.modelType==null&&(i.modelType=ye.modelType),i.maxFaces==null&&(i.maxFaces=ye.maxFaces),i}(a),[4,(t=new Ti(e)).initialize()];case 1:return s.sent(),[2,t]}})})}function wi(a,e,t,s){var n=a.width,i=a.height,o=1,u=Math.cos(a.rotation),p=Math.sin(a.rotation),l=a.xCenter,m=a.yCenter,c=1/e,d=1/t,h=new Array(16);return h[0]=n*u*o*c,h[1]=-i*p*c,h[2]=0,h[3]=(-.5*n*u*o+.5*i*p+l)*c,h[4]=n*p*o*d,h[5]=i*u*d,h[6]=0,h[7]=(-.5*i*u-.5*n*p*o+m)*d,h[8]=0,h[9]=0,h[10]=n*c,h[11]=0,h[12]=0,h[13]=0,h[14]=0,h[15]=1,function(f){if(f.length!==16)throw new Error("Array length must be 16 but got ".concat(f.length));return[[f[0],f[1],f[2],f[3]],[f[4],f[5],f[6],f[7]],[f[8],f[9],f[10],f[11]],[f[12],f[13],f[14],f[15]]]}(h)}function st(a){return a instanceof se?{height:a.shape[0],width:a.shape[1]}:{height:a.height,width:a.width}}function rt(a){return a instanceof se?a:Ur(a)}function fe(a,e){K(a.width!==0,function(){return"".concat(e," width cannot be 0.")}),K(a.height!==0,function(){return"".concat(e," height cannot be 0.")})}function _i(a,e){var t=function(s,n,i,o){var u=n-s,p=o-i,l=p/u;return{scale:l,offset:i-s*l}}(0,255,e[0],e[1]);return E(function(){return U(x(a,t.scale),t.offset)})}function Oi(a,e,t){var s=e.outputTensorSize,n=e.keepAspectRatio,i=e.borderMode,o=e.outputTensorFloatRange,u=st(a),p=function(d,h){return{xCenter:.5*d.width,yCenter:.5*d.height,width:d.width,height:d.height,rotation:0}}(u),l=function(d,h,f){if(f===void 0&&(f=!1),!f)return{top:0,left:0,right:0,bottom:0};var g=h.height,y=h.width;fe(h,"targetSize"),fe(d,"roi");var N,T,w=g/y,b=d.height/d.width,S=0,_=0;return w>b?(N=d.width,T=d.width*w,_=(1-b/w)/2):(N=d.height/w,T=d.height,S=(1-w/b)/2),d.width=N,d.height=T,{top:_,left:S,right:S,bottom:_}}(p,s,n),m=wi(p,u.width,u.height),c=E(function(){var d=rt(a),h=Ve(function(y,N,T){return fe(T,"inputResolution"),[1/T.width*y[0][0]*N.width,1/T.height*y[0][1]*N.width,y[0][3]*N.width,1/T.width*y[1][0]*N.height,1/T.height*y[1][1]*N.height,y[1][3]*N.height,0,0]}(m,u,s),[1,8]),f=i==="zero"?"constant":"nearest",g=de.transform(Ce(De(d,"float32")),h,"bilinear",f,0,[s.height,s.width]);return o!=null?_i(g,o):g});return{imageTensor:c,padding:l,transformationMatrix:m}}function Ge(a){a.reduceBoxesInLowestLayer==null&&(a.reduceBoxesInLowestLayer=!1),a.interpolatedScaleAspectRatio==null&&(a.interpolatedScaleAspectRatio=1),a.fixedAnchorSize==null&&(a.fixedAnchorSize=!1);for(var e=[],t=0;t<a.numLayers;){for(var s=[],n=[],i=[],o=[],u=t;u<a.strides.length&&a.strides[u]===a.strides[t];){var p=Ke(a.minScale,a.maxScale,u,a.strides.length);if(u===0&&a.reduceBoxesInLowestLayer)i.push(1),i.push(2),i.push(.5),o.push(.1),o.push(p),o.push(p);else{for(var l=0;l<a.aspectRatios.length;++l)i.push(a.aspectRatios[l]),o.push(p);if(a.interpolatedScaleAspectRatio>0){var m=u===a.strides.length-1?1:Ke(a.minScale,a.maxScale,u+1,a.strides.length);o.push(Math.sqrt(p*m)),i.push(a.interpolatedScaleAspectRatio)}}u++}for(var c=0;c<i.length;++c){var d=Math.sqrt(i[c]);s.push(o[c]/d),n.push(o[c]*d)}var h=0,f=0;if(a.featureMapHeight.length>0)h=a.featureMapHeight[t],f=a.featureMapWidth[t];else{var g=a.strides[t];h=Math.ceil(a.inputSizeHeight/g),f=Math.ceil(a.inputSizeWidth/g)}for(var y=0;y<h;++y)for(var N=0;N<f;++N)for(var T=0;T<s.length;++T){var w={xCenter:(N+a.anchorOffsetX)/f,yCenter:(y+a.anchorOffsetY)/h,width:0,height:0};a.fixedAnchorSize?(w.width=1,w.height=1):(w.width=n[T],w.height=s[T]),e.push(w)}t=u}return e}function Ke(a,e,t,s){return s===1?.5*(a+e):a+(e-a)*t/(s-1)}function Qe(a,e){var t=e[0],s=e[1];return[t*a[0]+s*a[1]+a[3],t*a[4]+s*a[5]+a[7]]}function vi(a){return E(function(){var e=function(n){return E(function(){return[I(n,[0,0,0],[1,-1,1]),I(n,[0,0,1],[1,-1,-1])]})}(a),t=e[0],s=e[1];return{boxes:A(s),logits:A(t)}})}function Ii(a,e,t,s){return $(this,void 0,void 0,function(){var n,i,o,u,p;return j(this,function(l){switch(l.label){case 0:return a.sort(function(m,c){return Math.max.apply(Math,c.score)-Math.max.apply(Math,m.score)}),n=Ve(a.map(function(m){return[m.locationData.relativeBoundingBox.yMin,m.locationData.relativeBoundingBox.xMin,m.locationData.relativeBoundingBox.yMax,m.locationData.relativeBoundingBox.xMax]})),i=Y(a.map(function(m){return m.score[0]})),[4,de.nonMaxSuppressionAsync(n,i,e,t)];case 1:return[4,(o=l.sent()).array()];case 2:return u=l.sent(),p=a.filter(function(m,c){return u.indexOf(c)>-1}),Z([n,i,o]),[2,p]}})})}function Ei(a,e,t){return $(this,void 0,void 0,function(){var s,n,i,o,u;return j(this,function(p){switch(p.label){case 0:return s=a[0],n=a[1],i=function(l,m,c){return E(function(){var d,h,f,g;c.reverseOutputOrder?(h=A(I(l,[0,c.boxCoordOffset+0],[-1,1])),d=A(I(l,[0,c.boxCoordOffset+1],[-1,1])),g=A(I(l,[0,c.boxCoordOffset+2],[-1,1])),f=A(I(l,[0,c.boxCoordOffset+3],[-1,1]))):(d=A(I(l,[0,c.boxCoordOffset+0],[-1,1])),h=A(I(l,[0,c.boxCoordOffset+1],[-1,1])),f=A(I(l,[0,c.boxCoordOffset+2],[-1,1])),g=A(I(l,[0,c.boxCoordOffset+3],[-1,1]))),h=U(x(C(h,c.xScale),m.w),m.x),d=U(x(C(d,c.yScale),m.h),m.y),c.applyExponentialOnBoxSize?(f=x(Ne(C(f,c.hScale)),m.h),g=x(Ne(C(g,c.wScale)),m.w)):(f=x(C(f,c.hScale),m.h),g=x(C(g,c.wScale),m.h));var y=be(d,C(f,2)),N=be(h,C(g,2)),T=U(d,C(f,2)),w=U(h,C(g,2)),b=ee([k(y,[c.numBoxes,1]),k(N,[c.numBoxes,1]),k(T,[c.numBoxes,1]),k(w,[c.numBoxes,1])],1);if(c.numKeypoints)for(var S=0;S<c.numKeypoints;++S){var _=c.keypointCoordOffset+S*c.numValuesPerKeypoint,D=void 0,B=void 0;c.reverseOutputOrder?(D=A(I(l,[0,_],[-1,1])),B=A(I(l,[0,_+1],[-1,1]))):(B=A(I(l,[0,_],[-1,1])),D=A(I(l,[0,_+1],[-1,1])));var X=U(x(C(D,c.xScale),m.w),m.x),H=U(x(C(B,c.yScale),m.h),m.y);b=ee([b,k(X,[c.numBoxes,1]),k(H,[c.numBoxes,1])],1)}return b})}(n,e,t),o=E(function(){var l=s;return t.sigmoidScore?(t.scoreClippingThresh!=null&&(l=Ye(s,-t.scoreClippingThresh,t.scoreClippingThresh)),l=Ze(l)):l}),[4,Ai(i,o,t)];case 1:return u=p.sent(),Z([i,o]),[2,u]}})})}function Ai(a,e,t){return $(this,void 0,void 0,function(){var s,n,i,o,u,p,l,m,c,d,h,f;return j(this,function(g){switch(g.label){case 0:return s=[],[4,a.data()];case 1:return n=g.sent(),[4,e.data()];case 2:for(i=g.sent(),o=0;o<t.numBoxes;++o)if(!(t.minScoreThresh!=null&&i[o]<t.minScoreThresh||(u=o*t.numCoords,p=ki(n[u+0],n[u+1],n[u+2],n[u+3],i[o],t.flipVertically,o),(l=p.locationData.relativeBoundingBox).width<0||l.height<0))){if(t.numKeypoints>0)for((m=p.locationData).relativeKeypoints=[],c=t.numKeypoints*t.numValuesPerKeypoint,d=0;d<c;d+=t.numValuesPerKeypoint)h=u+t.keypointCoordOffset+d,f={x:n[h+0],y:t.flipVertically?1-n[h+1]:n[h+1]},m.relativeKeypoints.push(f);s.push(p)}return[2,s]}})})}function ki(a,e,t,s,n,i,o){return{score:[n],ind:o,locationData:{relativeBoundingBox:{xMin:e,yMin:i?1-t:a,xMax:s,yMax:i?1-a:t,width:s-e,height:t-a}}}}var zi={reduceBoxesInLowestLayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:4,minScale:.1484375,maxScale:.75,inputSizeHeight:128,inputSizeWidth:128,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,16,16],aspectRatios:[1],fixedAnchorSize:!0},Li={reduceBoxesInLowestLayer:!1,interpolatedScaleAspectRatio:0,featureMapHeight:[],featureMapWidth:[],numLayers:1,minScale:.1484375,maxScale:.75,inputSizeHeight:192,inputSizeWidth:192,anchorOffsetX:.5,anchorOffsetY:.5,strides:[4],aspectRatios:[1],fixedAnchorSize:!0},ge={runtime:"tfjs",modelType:"short",maxFaces:1,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/face_detection/short/1"},Di={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:896,numCoords:16,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:6,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:128,yScale:128,hScale:128,wScale:128,minScoreThresh:.5},Ci={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2304,numCoords:16,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:6,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:192,yScale:192,hScale:192,wScale:192,minScoreThresh:.6},Vi=.3,xi={outputTensorSize:{width:128,height:128},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},Fi={outputTensorSize:{width:192,height:192},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},Le,Ri=function(){function a(e,t,s){this.detectorModel=t,this.maxFaces=s,e==="full"?(this.imageToTensorConfig=Fi,this.tensorsToDetectionConfig=Ci,this.anchors=Ge(Li)):(this.imageToTensorConfig=xi,this.tensorsToDetectionConfig=Di,this.anchors=Ge(zi));var n=Y(this.anchors.map(function(p){return p.width})),i=Y(this.anchors.map(function(p){return p.height})),o=Y(this.anchors.map(function(p){return p.xCenter})),u=Y(this.anchors.map(function(p){return p.yCenter}));this.anchorTensor={x:o,y:u,w:n,h:i}}return a.prototype.dispose=function(){this.detectorModel.dispose(),Z([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h])},a.prototype.reset=function(){},a.prototype.detectFaces=function(e,t){return t===void 0&&(t=!1),$(this,void 0,void 0,function(){var s,n,i,o,u,p,l,m,c,d,h;return j(this,function(f){switch(f.label){case 0:return e==null?(this.reset(),[2,[]]):(s=E(function(){var g=De(rt(e),"float32");return t&&(g=A(de.flipLeftRight(Ce(g,0)),[0])),g}),n=Oi(s,this.imageToTensorConfig),i=n.imageTensor,o=n.transformationMatrix,u=this.detectorModel.execute(i,"Identity:0"),p=vi(u),l=p.boxes,[4,Ei([m=p.logits,l],this.anchorTensor,this.tensorsToDetectionConfig)]);case 1:return(c=f.sent()).length===0?(Z([s,i,u,m,l]),[2,c]):[4,Ii(c,this.maxFaces,Vi)];case 2:return d=f.sent(),h=function(g,y){g===void 0&&(g=[]);var N,T=(N=y,[].concat.apply([],N));return g.forEach(function(w){var b=w.locationData;b.relativeKeypoints.forEach(function(H){var J=Qe(T,[H.x,H.y]),ne=J[0],ie=J[1];H.x=ne,H.y=ie});var S=b.relativeBoundingBox,_=Number.MAX_VALUE,D=Number.MAX_VALUE,B=Number.MIN_VALUE,X=Number.MIN_VALUE;[[S.xMin,S.yMin],[S.xMin+S.width,S.yMin],[S.xMin+S.width,S.yMin+S.height],[S.xMin,S.yMin+S.height]].forEach(function(H){var J=Qe(T,H),ne=J[0],ie=J[1];_=Math.min(_,ne),B=Math.max(B,ne),D=Math.min(D,ie),X=Math.max(X,ie)}),b.relativeBoundingBox={xMin:_,xMax:B,yMin:D,yMax:X,width:B-_,height:X-D}}),g}(d,o),Z([s,i,u,m,l]),[2,h]}})})},a.prototype.estimateFaces=function(e,t){return $(this,void 0,void 0,function(){var s,n;return j(this,function(i){return s=st(e),n=!!t&&t.flipHorizontal,[2,this.detectFaces(e,n).then(function(o){return o.map(function(u){for(var p=u.locationData.relativeKeypoints.map(function(f,g){return W(W({},f),{x:f.x*s.width,y:f.y*s.height,name:at[g]})}),l=u.locationData.relativeBoundingBox,m=0,c=["width","xMax","xMin"];m<c.length;m++)l[c[m]]*=s.width;for(var d=0,h=["height","yMax","yMin"];d<h.length;d++)l[h[d]]*=s.height;return{keypoints:p,box:l}})})]})})},a}();function Pi(a){return $(this,void 0,void 0,function(){var e,t,s;return j(this,function(n){switch(n.label){case 0:return e=function(i){if(i==null)return W({},ge);var o=W({},i);return o.modelType==null&&(o.modelType=ge.modelType),o.maxFaces==null&&(o.maxFaces=ge.maxFaces),o.detectorModelUrl==null&&(o.modelType==="full"?o.detectorModelUrl="https://tfhub.dev/mediapipe/tfjs-model/face_detection/full/1":o.detectorModelUrl="https://tfhub.dev/mediapipe/tfjs-model/face_detection/short/1"),o}(a),t=typeof e.detectorModelUrl=="string"&&e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,[4,Ni(e.detectorModelUrl,{fromTFHub:t})];case 1:return s=n.sent(),[2,new Ri(e.modelType,s,e.maxFaces)]}})})}function Bi(a,e){return $(this,void 0,void 0,function(){var t,s;return j(this,function(n){if(a===Le.MediaPipeFaceDetector){if(s=void 0,(t=e)!=null){if(t.runtime==="tfjs")return[2,Pi(t)];if(t.runtime==="mediapipe")return[2,Si(t)];s=t.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(s))}throw new Error("".concat(a," is not a supported model name."))})})}(function(a){a.MediaPipeFaceDetector="MediaPipeFaceDetector"})(Le||(Le={}));export{Ti as MediaPipeFaceDetectorMediaPipe,Ri as MediaPipeFaceDetectorTfjs,Le as SupportedModels,Bi as createDetector};
